# display.bld - Parse display emitter as BLD structure
#
# Structure IS Computation: traversing this structure emits parse output.
# Input structure is pre-loaded into state variables via load_struct_to_state().
#
# State variables expected:
#   $struct_name - structure name
#   $struct_returns - returns value
#   $struct_boundaries - list of boundary dicts
#   $struct_links - list of link dicts
#   $struct_dimensions - list of dimension dicts

structure DisplayEmitter

# Output dimension
D output: N [output, sequential]

# Section types - emit structure in human-readable format
B section: name | blank1 | boundaries_section | blank2 | links_section | blank3 | dimensions_section | returns_section
  name -> emit("structure "), emit($struct_name), emit("\n")
  blank1 -> emit("\n")
  boundaries_section -> foreach(struct_boundaries, boundary_output)
  blank2 -> emit("\n")
  links_section -> foreach(struct_links, link_output)
  blank3 -> emit("\n")
  dimensions_section -> foreach(struct_dimensions, dimension_output)
  returns_section -> if_has(struct_returns, returns_output)

# Boundary output - partition name matches foreach target, uses(_internal) prevents direct visitation
B boundary_output: boundary_output
  boundary_output -> uses(_internal), emit("B "), emit_field("name"), emit(": "), emit_field("partitions_display"), emit("\n")

# Link output
B link_output: link_output
  link_output -> uses(_internal), emit("L "), emit_field("name"), emit(": "), emit_field("source"), emit(" -> "), emit_field("target"), emit_field("attrs_display"), emit("\n")

# Dimension output
B dimension_output: dimension_output
  dimension_output -> uses(_internal), emit("D "), emit_field("name"), emit(": "), emit_field("extent"), emit_field("props_display"), emit("\n")

# Returns output - called via if_has, not foreach
B returns_output: returns_output
  returns_output -> uses(_internal), emit("\nreturns: "), emit($struct_returns), emit("\n")

# Emission order
L emit_all: section -> output (deps=1, sequential=true)

returns: output
