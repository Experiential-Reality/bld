# CLI Code - BLD structure
#
# Registers:
#   r12: saved argv[1]
#   r13: fd
#   r14: input pointer
#   r15: output count
#   rbx: accumulator
#
# Buffers:
#   input:  0x401000 (4KB)
#   output: 0x402000 (4KB)

# ===== _start =====
mov: rax, [rsp]
cmp: rax, 2
jcc/l: no_arg
mov: rdi, [rsp+16]
mov: r12, rdi

# ===== open_file =====
mov: rax, 2
xor: rsi, rsi
xor: rdx, rdx
syscall
test: rax, rax
jcc/s: open_error
mov: r13, rax

# ===== read_file =====
xor: rax, rax
mov: rdi, r13
mov: rsi, 0x401000
mov: rdx, 4096
syscall
mov: r14, rax

# ===== close_file =====
mov: rax, 3
mov: rdi, r13
syscall

# ===== init_parse =====
mov: r14, 0x401000
xor: r15, r15

# ===== parse_loop =====
movzx: rax, byte [r14]
test: al, al
jcc/e: write_out

# ===== skip_ws =====
cmp: al, 0x20
jcc/e: skip_char
cmp: al, 0x09
jcc/e: skip_char
jmp: classify

skip_char:
inc: r14
jmp: parse_loop

# ===== classify =====
cmp: al, 0x0A
jcc/e: next_line
cmp: al, 0x23
jcc/e: skip_to_nl
cmp: al, 0x30
jcc/ne: check_decimal
movzx: rcx, byte [r14+1]
cmp: cl, 0x78
jcc/e: parse_hex
cmp: cl, 0x58
jcc/e: parse_hex

check_decimal:
cmp: al, 0x30
jcc/l: skip_to_nl
cmp: al, 0x39
jcc/g: skip_to_nl
jmp: parse_decimal

# ===== parse_hex =====
add: r14, 2
xor: rbx, rbx

hex_loop:
movzx: rax, byte [r14]
cmp: al, 0x0A
jcc/e: hex_done
cmp: al, 0x20
jcc/e: hex_done
cmp: al, 0x30
jcc/l: hex_done
cmp: al, 0x39
jcc/le: hex_digit
cmp: al, 0x61
jcc/l: hex_upper
cmp: al, 0x66
jcc/g: hex_done
sub: al, 0x57
jmp: hex_accum

hex_upper:
cmp: al, 0x41
jcc/l: hex_done
cmp: al, 0x46
jcc/g: hex_done
sub: al, 0x37
jmp: hex_accum

hex_digit:
sub: al, 0x30

hex_accum:
shl: rbx, 4
or: rbx, rax
inc: r14
jmp: hex_loop

hex_done:
jmp: emit_byte

# ===== parse_decimal =====
xor: rbx, rbx

dec_loop:
movzx: rax, byte [r14]
cmp: al, 0x30
jcc/l: dec_done
cmp: al, 0x39
jcc/g: dec_done
sub: al, 0x30
imul: rbx, rbx, 10
add: rbx, rax
inc: r14
jmp: dec_loop

dec_done:

# ===== emit_byte =====
mov: rax, 0x402000
add: rax, r15
mov: [rax], bl
inc: r15
jmp: skip_to_nl

# ===== next_line =====
inc: r14
jmp: parse_loop

# ===== skip_to_nl =====
movzx: rax, byte [r14]
cmp: al, 0x0A
jcc/e: next_line
test: al, al
jcc/e: write_out
inc: r14
jmp: skip_to_nl

# ===== write_out =====
mov: rax, 1
mov: rdi, 1
mov: rsi, 0x402000
mov: rdx, r15
syscall

# ===== exit =====
mov: rax, 60
xor: rdi, rdi
syscall

# ===== open_error =====
mov: rax, 1
mov: rdi, 2
lea: rsi, [rip+error_msg]
mov: rdx, 12
syscall
mov: rax, 60
mov: rdi, 1
syscall

# ===== no_arg =====
mov: rax, 60
mov: rdi, 1
syscall

# ===== data =====
error_msg: "open error\n"
