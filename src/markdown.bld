# markdown.bld - Markdown emitter as BLD structure
#
# Structure IS Computation: traversing this structure emits markdown.
# Input structure is pre-loaded into state variables via load_struct_to_state().
#
# State variables expected:
#   $struct_name - structure name
#   $struct_returns - returns value
#   $struct_boundaries - list of boundary dicts
#   $struct_links - list of link dicts
#   $struct_dimensions - list of dimension dicts
#   $struct_b_cost, $struct_d_extent, $struct_l_cost, $struct_total_cost
#
# Cost = B_sections + D_elements Ã— L_emit
#   B_sections = 7 section types (invariant)
#   D_elements = |B| + |L| + |D| of input structure
#   L_emit = constant per element
#   Total = O(N) where N = structure size

structure MarkdownEmitter

# Output dimension
D output: N [output, sequential]

# Section types - each section emits different markdown
B section: header | cost | hr | boundaries_section | links_section | dimensions_section | returns_section
  header -> emit("# "), emit($struct_name), emit("\n")
  cost -> emit("\n**Cost**: "), emit_cost_formula(), emit("\n")
  hr -> emit("\n---\n")
  boundaries_section -> if_has(struct_boundaries, boundaries_header, boundaries_rows)
  links_section -> if_has(struct_links, links_header, links_rows)
  dimensions_section -> if_has(struct_dimensions, dimensions_header, dimensions_rows)
  returns_section -> if_has(struct_returns, returns_header)

# Boundaries - header emits table header, rows does foreach
B boundaries_header: boundaries_header
  boundaries_header -> uses(_internal), emit("\n## Boundaries (B)\n\n| Boundary | Partitions | Properties |\n|----------|------------|------------|\n")

B boundaries_rows: boundaries_rows
  boundaries_rows -> uses(_internal), foreach(struct_boundaries, boundary_row)

B boundary_row: boundary_row
  boundary_row -> uses(_internal), emit("| "), emit_field("name"), emit(" | "), emit_field("partitions_joined"), emit(" | topological |\n")

# Links - header emits table header, rows does foreach
B links_header: links_header
  links_header -> uses(_internal), emit("\n## Links (L)\n\n| Link | Source | Target | deps | Attributes |\n|------|--------|--------|------|------------|\n")

B links_rows: links_rows
  links_rows -> uses(_internal), foreach(struct_links, link_row)

B link_row: link_row
  link_row -> uses(_internal), emit("| "), emit_field("name"), emit(" | "), emit_field("source"), emit(" | "), emit_field("target"), emit(" | "), emit_field("deps"), emit(" | "), emit_field("attrs"), emit(" |\n")

# Dimensions - header emits table header, rows does foreach
B dimensions_header: dimensions_header
  dimensions_header -> uses(_internal), emit("\n## Dimensions (D)\n\n| Dimension | Extent | Properties |\n|-----------|--------|------------|\n")

B dimensions_rows: dimensions_rows
  dimensions_rows -> uses(_internal), foreach(struct_dimensions, dimension_row)

B dimension_row: dimension_row
  dimension_row -> uses(_internal), emit("| "), emit_field("name"), emit(" | "), emit_field("extent"), emit(" | "), emit_field("props"), emit(" |\n")

# Returns section - called via if_has
B returns_header: returns_header
  returns_header -> uses(_internal), emit("\n## Returns\n\n`"), emit($struct_returns), emit("`\n")

# Emission order
L emit_all: section -> output (deps=1, sequential=true)

returns: output
