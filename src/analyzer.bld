# BLD Analyzer - applies the three questions to extract structure
#
# The Three Questions (Discovery Method):
#   Q1: Where does behavior partition? → Boundaries (B)
#   Q2: What connects to what? → Links (L)
#   Q3: What repeats? → Dimensions (D)
#
# Output: Structure S = (B, L, D) mapping to Lie algebra:
#   D = generators (directions of transformation)
#   L = structure constants (how generators interact)
#   B = topology (compact/closed vs non-compact/open)
#
# Cost(analyze) = B_questions + D_elements × L_extract
#   = 3 + N × 1 = O(N)

structure Analyzer

# =============================================================================
# DIMENSIONS - What repeats in analysis
# =============================================================================

D source: 1 [input]
D structure: 1 [output, type=Structure]

# Extracted elements
D boundaries: N [output, parallel]
D links: M [output, parallel]
D dimensions: K [output, parallel]

# The three questions can be asked in parallel
D questions: 3 [parallel]

# =============================================================================
# BOUNDARIES - Where analysis behavior partitions
# =============================================================================

# The three questions (mutually exclusive extraction targets)
B question: q1_boundaries | q2_links | q3_dimensions
  q1_boundaries -> extract_boundaries($source)
  q2_links -> extract_links($source)
  q3_dimensions -> extract_dimensions($source)

# Q1: What indicates a boundary? (where behavior partitions)
B boundary_indicator: conditional | type_tag | threshold | mode | switch | enum
  conditional -> if_else_chain()
  type_tag -> isinstance_check()
  threshold -> comparison_operator()
  mode -> state_variable()
  switch -> match_statement()
  enum -> enumeration_type()

# Q2: What indicates a link? (what connects)
B link_indicator: pointer | dependency | correlation | call | reference | import
  pointer -> address_of()
  dependency -> depends_on()
  correlation -> correlated_with()
  call -> function_call()
  reference -> variable_reference()
  import -> module_import()

# Q3: What indicates a dimension? (what repeats)
B dimension_indicator: array | loop | parallel | layer | batch | sequence
  array -> array_type()
  loop -> for_while_statement()
  parallel -> parallel_annotation()
  layer -> neural_layer()
  batch -> batch_dimension()
  sequence -> sequence_type()

# Analysis result status
B result_status: complete | partial | failed
  complete -> all_three_extracted()
  partial -> some_extracted()
  failed -> extraction_error()

# =============================================================================
# LINKS - How analysis connects
# =============================================================================

# Main analysis flow
L analyze: source -> structure (deps=1)

# The three questions (can run in parallel - deps=0)
L q1: source -> boundaries (deps=0)
  # Look for: conditionals, type tags, thresholds, modes
  # These partition behavior into mutually exclusive regions

L q2: source -> links (deps=0)
  # Look for: pointers, dependencies, correlations, calls
  # Compute: deps count, then rho = 1 - 1/(deps+1), then L = -½ ln(1-ρ²)

L q3: source -> dimensions (deps=0)
  # Look for: arrays, loops, parallel instances, layers
  # Record: extent (N, M, or concrete), properties (parallel, sequential, etc.)

# Combine results
L combine: (boundaries, links, dimensions) -> structure (deps=1)
  # Structure = (B, L, D) triple

# Validation
L validate_structure: structure -> validated (deps=0)
  # Check: boundaries partition (no overlap)
  # Check: links have valid sources/targets
  # Check: dimensions have valid extents

# =============================================================================
# SEMANTICS - Extraction rules
# =============================================================================

# Boundary extraction rules:
#   if ... elif ... else → B mode: case1 | case2 | case3
#   match x: case A: ... case B: ... → B x: A | B
#   isinstance(x, T) → B type: T | other
#   x > threshold → B region: above | below

# Link extraction rules:
#   y = f(x) → L f: x -> y
#   a depends on b → L dep: b -> a (deps=1)
#   c = g(a, b) → L g: (a, b) -> c (deps=2)

# Dimension extraction rules:
#   for i in range(N): → D i: N [sequential]
#   parallel for i: → D i: N [parallel]
#   x: list[T] → D x: len(x) [type=T]
#   batch_size = 32 → D batch: 32 [parallel]

# =============================================================================
# PARAMETERS
# =============================================================================

P max_boundary_depth: 10   # Max nesting for conditional extraction
P min_loop_iterations: 2   # Min iterations to count as dimension

# =============================================================================
# RETURNS
# =============================================================================

returns: structure
