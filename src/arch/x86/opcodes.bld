# opcodes.bld - x86 opcodes ARE bytes
#
# Opcodes decompose by their bit structure.
# Many opcodes partition at bit 0 for size/condition.

structure Opcodes

# Escape prefix (for 2-byte opcodes)
D escape: 1 [byte]
B escape: 0x0F

# SYSCALL (after 0F)
D syscall: 1 [byte]
B syscall: 0x05

# MOV r64, imm64 base (B8+rd)
D mov_ri: 1 [byte]
B mov_ri: 0xB8

# MOV mr/rm - 1000100x where x = direction (1=rm, 0=mr)
D mov_mr: 1 [byte]
B mov_mr: 0x89

D mov_rm: 1 [byte]
B mov_rm: 0x8B

# CMP - 0011100x where x = size (0=byte, 1=qword)
D cmp: 1 [byte]
B cmp: base | size
  base -> 0x38
  size -> byte | qword
    byte -> 0
    qword -> 1

# TEST - 1000010x where x = size (0=byte, 1=qword)
D test: 1 [byte]
B test: base | size
  base -> 0x84
  size -> byte | qword
    byte -> 0
    qword -> 1

# ADD r/m64, imm8
D add_mi8: 1 [byte]
B add_mi8: 0x83

# JMP rel8
D jmp8: 1 [byte]
B jmp8: 0xEB

# JMP rel32
D jmp32: 1 [byte]
B jmp32: 0xE9

# Jcc short - 0111010x where x = condition (0=equal, 1=not_equal)
D jcc8: 1 [byte]
B jcc8: base | cond
  base -> 0x74
  cond -> eq | ne
    eq -> 0
    ne -> 1

# Jcc near (after 0F) - 1000010x where x = condition (0=equal, 1=not_equal)
D jcc32: 1 [byte]
B jcc32: base | cond
  base -> 0x84
  cond -> eq | ne
    eq -> 0
    ne -> 1

# INC/DEC r/m64
D inc_dec: 1 [byte]
B inc_dec: 0xFF

# CMP rax, imm32
D cmp_rax_imm: 1 [byte]
B cmp_rax_imm: 0x3D

# MOVZX (after 0F) - 1011011x where x = size (0=byte, 1=word)
D movzx: 1 [byte]
B movzx: base | size
  base -> 0xB6
  size -> byte | word
    byte -> 0
    word -> 1

returns: opcodes
