# hello.bld - Hello World as executable BLD
#
# This structure, when traversed, emits a working x86-64 Linux program.
# All bytes are explicit - this IS the program.

structure Hello

D output: N [output, sequential]

# Program layout (all offsets calculated):
#   0-6:   mov rax, 1
#   7-13:  mov rdi, 1
#   14-20: lea rsi, [rip+0x19]  (offset to string at 46)
#   21-27: mov rdx, 12
#   28-29: syscall
#   30-36: mov rax, 60
#   37-43: mov rdi, 0
#   44-45: syscall
#   46-57: "Hello, BLD!\n"

B code: write_syscall | exit_syscall | string_data
  # mov rax, 1 (sys_write)
  write_syscall -> emit_byte(0x48), emit_byte(0xC7), emit_byte(0xC0), emit_byte(0x01), emit_byte(0x00), emit_byte(0x00), emit_byte(0x00), emit_byte(0x48), emit_byte(0xC7), emit_byte(0xC7), emit_byte(0x01), emit_byte(0x00), emit_byte(0x00), emit_byte(0x00), emit_byte(0x48), emit_byte(0x8D), emit_byte(0x35), emit_byte(0x19), emit_byte(0x00), emit_byte(0x00), emit_byte(0x00), emit_byte(0x48), emit_byte(0xC7), emit_byte(0xC2), emit_byte(0x0C), emit_byte(0x00), emit_byte(0x00), emit_byte(0x00), emit_byte(0x0F), emit_byte(0x05)

  # mov rax, 60; mov rdi, 0; syscall
  exit_syscall -> emit_byte(0x48), emit_byte(0xC7), emit_byte(0xC0), emit_byte(0x3C), emit_byte(0x00), emit_byte(0x00), emit_byte(0x00), emit_byte(0x48), emit_byte(0xC7), emit_byte(0xC7), emit_byte(0x00), emit_byte(0x00), emit_byte(0x00), emit_byte(0x00), emit_byte(0x0F), emit_byte(0x05)

  # "Hello, BLD!\n" = 48 65 6c 6c 6f 2c 20 42 4c 44 21 0a
  string_data -> emit_byte(0x48), emit_byte(0x65), emit_byte(0x6C), emit_byte(0x6C), emit_byte(0x6F), emit_byte(0x2C), emit_byte(0x20), emit_byte(0x42), emit_byte(0x4C), emit_byte(0x44), emit_byte(0x21), emit_byte(0x0A)

L emit: code -> output (deps=1)

returns: output
