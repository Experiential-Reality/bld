# format/elf.bld - ELF64 executable format
#
# Level 1: uses emit/ only (down)
#
# Structural sizes emerge from composition:
#   elf_header: 4×byte + 12×byte + 2×u16 + 2×u32 + 3×u64 + u32 + 6×u16
#             = 16×emit/byte + 8×emit/u16 + 3×emit/u32 + 3×emit/u64
#             = 16×1 + 8×2 + 3×4 + 3×8 = 16 + 16 + 12 + 24 = 68?
#   Wait, let me recount from actual fields below...
#
#   elf_header fields (actual):
#     magic: 4×byte = 4
#     class: byte = 1
#     data: byte = 1
#     version: byte = 1
#     osabi: byte = 1
#     pad: 8×byte = 8
#     e_type: u16 = 2
#     e_machine: u16 = 2
#     e_version: u32 = 4
#     e_entry: u64 = 8
#     e_phoff: u64 = 8
#     e_shoff: u64 = 8
#     e_flags: u32 = 4
#     e_ehsize: u16 = 2
#     e_phentsize: u16 = 2
#     e_phnum: u16 = 2
#     e_shentsize: u16 = 2
#     e_shnum: u16 = 2
#     e_shstrndx: u16 = 2
#     TOTAL = 4+1+1+1+1+8+2+2+4+8+8+8+4+2+2+2+2+2+2 = 64
#
#   phdr fields:
#     p_type: u32 = 4
#     p_flags: u32 = 4
#     p_offset: u64 = 8
#     p_vaddr: u64 = 8
#     p_paddr: u64 = 8
#     p_filesz: u64 = 8
#     p_memsz: u64 = 8
#     p_align: u64 = 8
#     TOTAL = 4+4+8+8+8+8+8+8 = 56

structure ELF64

# Structural sizes - D extent IS the size (emerges from composition)
# Field counts:
D elf_header: 19 [composed]
D phdr: 8 [composed]

# Byte sizes - structural, derived from emit/* composition:
#   elf_header = 16×emit/byte.size + 8×emit/u16.bytes + 3×emit/u32.bytes + 3×emit/u64.bytes
#              = 16×1 + 8×2 + 3×4 + 3×8 = 16 + 16 + 12 + 24 = 68 ← WRONG!
# Let me recount properly:
#   magic: 4×byte, class: 1×byte, data: 1×byte, version: 1×byte, osabi: 1×byte, pad: 8×byte
#   = 16 bytes
#   e_type: u16, e_machine: u16 = 4 bytes
#   e_version: u32 = 4 bytes
#   e_entry: u64, e_phoff: u64, e_shoff: u64 = 24 bytes
#   e_flags: u32 = 4 bytes
#   e_ehsize: u16, e_phentsize: u16, e_phnum: u16, e_shentsize: u16, e_shnum: u16, e_shstrndx: u16 = 12 bytes
#   TOTAL = 16 + 4 + 4 + 24 + 4 + 12 = 64 ✓
#
#   phdr = 2×emit/u32.bytes + 6×emit/u64.bytes = 2×4 + 6×8 = 8 + 48 = 56 ✓

# =============================================================================
# STRUCTURAL SIZES - Computed from emit/* composition using size()
# =============================================================================
#
# Size IS structure. These are computed from emit/* D extents:
#   elf_header = size(emit/byte) × 16 + size(emit/u16) × 8 + size(emit/u32) × 2 + size(emit/u64) × 3
#   phdr = size(emit/u32) × 2 + size(emit/u64) × 6
#   shdr = size(emit/u32) × 2 + size(emit/u64) × 4 + size(emit/u16) × 4
#   page = os parameter (4096 on Linux x86-64)

D phases: 4 [composed]

B sizes: compute_elf | compute_phdr | compute_shdr | compute_page
  # elf_header = 16 bytes + 8 u16 + 2 u32 + 3 u64
  compute_elf -> set(elf_header_size, size(emit/byte) * 16 + size(emit/u16) * 8 + size(emit/u32) * 2 + size(emit/u64) * 3)
  # phdr = 2 u32 + 6 u64
  compute_phdr -> set(phdr_size, size(emit/u32) * 2 + size(emit/u64) * 6)
  # shdr = 4 u32 + 6 u64 = 16 + 48 = 64
  compute_shdr -> set(shdr_size, size(emit/u32) * 4 + size(emit/u64) * 6)
  # page size from OS structure
  compute_page -> set(page_size, size(os/linux/memory/page))

# =============================================================================
# ELF HEADER (64 bytes, 19 fields)
# =============================================================================

B elf_header: magic | class | data | version | osabi | pad | e_type | e_machine | e_version | e_entry | e_phoff | e_shoff | e_flags | e_ehsize | e_phentsize | e_phnum | e_shentsize | e_shnum | e_shstrndx
  magic -> set(value, 0x7f), uses=emit/byte, set(value, 0x45), uses=emit/byte, set(value, 0x4c), uses=emit/byte, set(value, 0x46), uses=emit/byte
  class -> set(value, 0x02), uses=emit/byte
  data -> set(value, 0x01), uses=emit/byte
  version -> set(value, 0x01), uses=emit/byte
  osabi -> set(value, 0x00), uses=emit/byte
  pad -> set(value, 0), uses=emit/byte, set(value, 0), uses=emit/byte, set(value, 0), uses=emit/byte, set(value, 0), uses=emit/byte, set(value, 0), uses=emit/byte, set(value, 0), uses=emit/byte, set(value, 0), uses=emit/byte, set(value, 0), uses=emit/byte
  e_type -> set(value, 0x0002), uses=emit/u16
  e_machine -> set(value, 0x003e), uses=emit/u16
  e_version -> set(value, 0x00000001), uses=emit/u32
  e_entry -> set(value, $entry), uses=emit/u64
  e_phoff -> set(value, $elf_header_size), uses=emit/u64
  e_shoff -> set(value, 0), uses=emit/u64
  e_flags -> set(value, 0), uses=emit/u32
  e_ehsize -> set(value, $elf_header_size), uses=emit/u16
  e_phentsize -> set(value, $phdr_size), uses=emit/u16
  e_phnum -> set(value, 1), uses=emit/u16
  e_shentsize -> set(value, $shdr_size), uses=emit/u16
  e_shnum -> set(value, 0), uses=emit/u16
  e_shstrndx -> set(value, 0), uses=emit/u16

# =============================================================================
# PROGRAM HEADER (56 bytes, 8 fields)
# =============================================================================

B phdr: p_type | p_flags | p_offset | p_vaddr | p_paddr | p_filesz | p_memsz | p_align
  p_type -> set(value, 1), uses=emit/u32
  p_flags -> set(value, 5), uses=emit/u32
  p_offset -> set(value, 0), uses=emit/u64
  p_vaddr -> set(value, $base_addr), uses=emit/u64
  p_paddr -> set(value, $base_addr), uses=emit/u64
  p_filesz -> set(value, $filesz), uses=emit/u64
  p_memsz -> set(value, $memsz), uses=emit/u64
  p_align -> set(value, $page_size), uses=emit/u64

# =============================================================================
# CODE
# =============================================================================

B code: bytes
  bytes -> replay($code)

returns: output
