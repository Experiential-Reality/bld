# Binary Translator: x86-64 → RISC-V 64
#
# BLD cross-compilation: same structure, different traversal direction.
#
# The magic: x86.bld with mode_codec=parse DECODES x86
#            riscv.bld with mode_codec=emit ENCODES RISC-V
#
# Cost(translate) = B_decode + D_instructions × L_map + B_encode

structure TranslateX86ToRISCV

# =============================================================================
# DIMENSIONS
# =============================================================================

D instructions: N [input, sequential]
D riscv_instructions: M [output, sequential]

# =============================================================================
# BOUNDARIES - Instruction mapping
# =============================================================================

# Syscall number translation: x86-64 → RISC-V Linux
B syscall_map: write | exit | read | open | close | mmap | munmap | brk
  write -> set(x86_num, 1), set(riscv_num, 64)
  exit -> set(x86_num, 60), set(riscv_num, 93)
  read -> set(x86_num, 0), set(riscv_num, 63)
  open -> set(x86_num, 2), set(riscv_num, 56)
  close -> set(x86_num, 3), set(riscv_num, 57)
  mmap -> set(x86_num, 9), set(riscv_num, 222)
  munmap -> set(x86_num, 11), set(riscv_num, 215)
  brk -> set(x86_num, 12), set(riscv_num, 214)

# Register mapping: x86-64 syscall convention → RISC-V syscall convention
# x86: rax=syscall#, rdi=arg0, rsi=arg1, rdx=arg2, r10=arg3, r8=arg4, r9=arg5
# RISC-V: a7=syscall#, a0=arg0, a1=arg1, a2=arg2, a3=arg3, a4=arg4, a5=arg5
B reg_map_syscall: rax | rdi | rsi | rdx | r10 | r8 | r9
  rax -> set(riscv_reg, 17)  # a7
  rdi -> set(riscv_reg, 10)  # a0
  rsi -> set(riscv_reg, 11)  # a1
  rdx -> set(riscv_reg, 12)  # a2
  r10 -> set(riscv_reg, 13)  # a3
  r8 -> set(riscv_reg, 14)   # a4
  r9 -> set(riscv_reg, 15)   # a5

# General register mapping for non-syscall code
B reg_map_general: rax | rbx | rcx | rdx | rsp | rbp | rsi | rdi | r8 | r9 | r10 | r11 | r12 | r13 | r14 | r15
  rax -> set(riscv_reg, 10)  # a0 (also return value)
  rbx -> set(riscv_reg, 19)  # s3 (callee-saved)
  rcx -> set(riscv_reg, 12)  # a2 (temp for non-syscall)
  rdx -> set(riscv_reg, 13)  # a3
  rsp -> set(riscv_reg, 2)   # sp
  rbp -> set(riscv_reg, 8)   # s0/fp
  rsi -> set(riscv_reg, 11)  # a1
  rdi -> set(riscv_reg, 10)  # a0
  r8 -> set(riscv_reg, 14)   # a4
  r9 -> set(riscv_reg, 15)   # a5
  r10 -> set(riscv_reg, 16)  # a6
  r11 -> set(riscv_reg, 17)  # a7
  r12 -> set(riscv_reg, 20)  # s4
  r13 -> set(riscv_reg, 21)  # s5
  r14 -> set(riscv_reg, 22)  # s6
  r15 -> set(riscv_reg, 23)  # s7

# Instruction translation: x86 operation → RISC-V operation(s)
B translate_op: mov_ri | mov_rr | add_rr | add_ri | sub_rr | sub_ri | xor_rr | and_rr | or_rr | cmp_rr | syscall | ret | nop | push | pop | jmp | je | jne
  # MOV r64, imm64 → LI rd, imm (may need LUI+ADDI)
  mov_ri -> set(riscv_op, li), set(needs_reloc, 0)

  # MOV r64, r64 → MV rd, rs (pseudo for ADDI rd, rs, 0)
  mov_rr -> set(riscv_op, mv)

  # ADD r64, r64 → ADD rd, rd, rs
  add_rr -> set(riscv_op, add)

  # ADD r64, imm → ADDI rd, rd, imm
  add_ri -> set(riscv_op, addi)

  # SUB r64, r64 → SUB rd, rd, rs
  sub_rr -> set(riscv_op, sub)

  # SUB r64, imm → ADDI rd, rd, -imm
  sub_ri -> set(riscv_op, addi), set(negate_imm, 1)

  # XOR r64, r64 → XOR rd, rd, rs
  xor_rr -> set(riscv_op, xor)

  # AND r64, r64 → AND rd, rd, rs
  and_rr -> set(riscv_op, and)

  # OR r64, r64 → OR rd, rd, rs
  or_rr -> set(riscv_op, or)

  # CMP r64, r64 → (no direct equivalent, sets flags for Jcc)
  # We track this for subsequent conditional jump
  cmp_rr -> set(riscv_op, cmp_pending), set(cmp_left, $dst), set(cmp_right, $src)

  # SYSCALL → ECALL
  syscall -> set(riscv_op, ecall)

  # RET → RET (pseudo for JALR zero, ra, 0)
  ret -> set(riscv_op, ret)

  # NOP → NOP (pseudo for ADDI zero, zero, 0)
  nop -> set(riscv_op, nop)

  # PUSH r64 → ADDI sp, sp, -8; SD rs, 0(sp)
  push -> set(riscv_op, push_seq)

  # POP r64 → LD rd, 0(sp); ADDI sp, sp, 8
  pop -> set(riscv_op, pop_seq)

  # JMP rel → JAL zero, offset
  jmp -> set(riscv_op, j)

  # JE/JZ → BEQ rs1, rs2, offset (using saved cmp operands)
  je -> set(riscv_op, beq)

  # JNE/JNZ → BNE rs1, rs2, offset
  jne -> set(riscv_op, bne)

# =============================================================================
# LINKS - Translation pipeline
# =============================================================================

# Phase 1: Parse x86 binary (uses x86.bld in parse mode)
L parse_x86: binary_input -> x86_instructions (deps=0)
  uses=X86, set(mode_codec, parse)

# Phase 2: Map each instruction to RISC-V equivalent
L map_instruction: x86_instruction -> riscv_instruction (deps=1)
  foreach=instructions

# Phase 3: Emit RISC-V binary (uses riscv.bld in emit mode)
L emit_riscv: riscv_instructions -> binary_output (deps=1)
  uses=RISCV, set(mode_codec, emit)

# Phase 4: Fixup relocations (addresses changed during translation)
L fixup_relocs: binary_output -> final_output (deps=1)

returns: final_output

# =============================================================================
# DATA - Architecture constants
# =============================================================================

# ELF machine types
# x86-64: 0x3E (62)
# RISC-V: 0xF3 (243)
# AArch64: 0xB7 (183)

