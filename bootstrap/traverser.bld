# BLD Traverser - the structure that interprets other structures
# The traverser IS a structure: T = (B_T, L_T, D_T)
#
# Cost(traverse) = B_visit + D_elements × L_step
#   B_visit = |visit_type| × |semantic_type| = 4 × 5 = 20 visit rules (invariant)
#   D_elements = N (scales with structure size)
#   L_step = cost per semantic interpretation (geometric)
#   Total: O(N) where N = |boundaries| + |links| + |dimensions|
#
# Key insight: Implementation emerges from structure-traverser alignment.
# The traverser doesn't "know" how to tokenize - it knows how to walk structure
# and evaluate semantic annotations.
#
# Usage: run() = traverse(self.structure)

structure Traverser

# Input: the structure to traverse (as parsed data)
D structure: 1 [input, type=ParsedStructure]

# State during traversal
D current_boundary: 1 [sequential]
D current_link: 1 [sequential]
D current_dim_index: 1 [sequential]
D state: N [sequential]  # Generic state storage

# Output: result of traversal (varies by structure type)
D result: N [output]

# Boundary 1: What kind of element are we visiting?
B visit_type: boundary | link | dimension | semantic
  boundary -> evaluate_partitions
  link -> follow_connection
  dimension -> iterate_elements
  semantic -> interpret_annotation

# Boundary 2: Traversal order (from deps)
B order: parallel | sequential
  parallel -> deps_zero, can_parallelize
  sequential -> deps_nonzero, must_sequence

# Boundary 3: Semantic instruction types
B semantic_type: pattern_match | text_match | action | template | compose
  pattern_match -> char_classification
  text_match -> keyword_detection
  action -> state_mutation
  template -> string_format
  compose -> call_substructure

# Links - traversal operations
L visit_boundary: structure -> current_boundary (deps=0)
L evaluate_partition: current_boundary -> state (deps=1)
L visit_link: structure -> current_link (deps=1)
L execute_link: current_link -> result (deps=1)
L visit_dimension: structure -> current_dim_index (deps=0)
L iterate: current_dim_index -> result (deps=1)

# Semantic interpretation
L parse_semantic: semantic_type -> instruction (deps=0)
L apply_semantic: instruction -> state (deps=1)

# Main entry point
L traverse: structure -> result (deps=1)

returns: result
