# conservation.bld - Test that structure is conserved during traversal
#
# BLD Conservation Law: Cost = B + DÃ—L
#   B = boundary partitions (topological, invariant)
#   D = repetition extent (multiplier)
#   L = link cost (geometric, scales with D)
#
# Key insight: D multiplies L, NOT B.
# You cannot create new boundaries during traversal.
#
# If uses=A where A has uses=A (recursion):
#   - Stack grows (D increases)
#   - But B stays constant
#   - Recursion is bounded by stack, not structure creation
#
# This test verifies: can uses= create unbounded structure?
# Answer: No. Conservation holds.

structure ConservationTest

# =============================================================================
# DIMENSIONS
# =============================================================================

D recursion_depth: 1 [input, default=0]
D output: M [output, sequential]

# =============================================================================
# BOUNDARIES - Test partitions
# =============================================================================

# Test: does recursive uses= terminate?
B test: recursive | non_recursive | base_case
  # recursive partition: uses=ConservationTest
  # If conservation FAILS, this would loop forever
  # If conservation HOLDS, this terminates (bounded by stack)
  recursive -> emit("entering recursive\n"), uses=ConservationTest, emit("exiting recursive\n")

  # non_recursive partition: simple emit
  non_recursive -> emit("non_recursive path\n")

  # base_case: terminates recursion
  base_case -> emit("base case reached\n")

# Depth check: prevent infinite recursion via explicit depth limit
B depth_check: under_limit | at_limit
  under_limit -> set(recursion_depth, $recursion_depth + 1)
  at_limit -> emit("depth limit reached, returning\n")

# =============================================================================
# LINKS - Test flow
# =============================================================================

# Main test: try recursive path
L test_recursive: input -> output (deps=1)

# Check depth before recursing
L check_depth: recursion_depth -> depth_check (deps=0)

# =============================================================================
# PARAMETERS
# =============================================================================

P max_depth: 3

# =============================================================================
# RETURNS
# =============================================================================

returns: output
