# dtrmm: Triangular matrix-matrix multiply
# B := alpha*op(A)*B or B := alpha*B*op(A) (A triangular)
# Pattern: Like dgemm but A uses only triangle
# BLAS signature: dtrmm_(side, uplo, trans, diag, m, n, alpha, A, lda, B, ldb)
#
# 16 kernels from 2^4 boundary combinations.
# Semantic keys standardized for machine interpretation.

structure dtrmm_

P side: char
P uplo: char
P trans: char
P diag: char
P m: int
P n: int
P alpha: double
D A: k_times_k [input]
P lda: int [stride]
D B: m_times_n [input, output]
P ldb: int [stride]

# Boundary 1: Which side of B the triangular matrix A appears
# Determines the k loop range and overall structure
B position: left | right
  left -> k_dim(M), outer_var(k), inner_var(i)
  right -> k_dim(N), outer_var(j), inner_var(k)

# Boundary 2: Which triangle of A is used
# Determines loop direction and inner bounds
# For backward loops, k_end is inclusive (>= end), for forward loops exclusive (< end)
B triangle: upper | lower
  upper -> k_start(0), k_end(K), k_direction(forward), inner_bound(< k), diag_after_inner
  lower -> k_start(K-1), k_end(0), k_direction(backward), inner_bound(> k), diag_before_inner

# Boundary 3: Whether to transpose A
# Determines A access pattern
B transpose: normal | transposed
  normal -> A_access(A[i + k * lda])
  transposed -> A_access(A[k + i * lda])

# Boundary 4: Whether diagonal is unit (implicit 1) or explicit
B diagonal: unit | non_unit
  unit -> skip_diagonal, diag_value(1.0)
  non_unit -> include_diagonal, diag_value(A[k + k * lda])

L trmm: A -> B (deps=1)

returns: void
