# BLD Lowering for x86-64 - convert BLD operations to x86 code
#
# Path-based composition: uses=arch/x86/mov/ri instead of mode_instruction
# Structure IS the interface - no hidden B.
#
# Cost(lower) = B_operations + D_instructions Ã— L_emit
#
# x86-64 Linux syscall convention:
#   rax = syscall number
#   rdi, rsi, rdx, r10, r8, r9 = arguments
#   syscall instruction

structure LoweringX86

# =============================================================================
# DIMENSIONS
# =============================================================================

D operations: N [input, from_structure]
D instructions: M [output, sequential]

# =============================================================================
# BOUNDARIES - Operation types that get lowered
# =============================================================================

# Main operation dispatch - each partition uses path-based structures
B operation: syscall_write | syscall_exit | syscall_read | syscall_open | read_argc | read_argv | strcmp | jmp_if_eq | jmp_if_ne

  # syscall_write: write(stdout, buffer, length)
  # mov rax, 1; mov rdi, 1; mov rsi, $buffer; mov rdx, $length; syscall
  syscall_write -> set(dst_lo, 0), set(dst_ext, 0), set(imm, 1), uses=arch/x86/mov/ri, set(dst_lo, 7), set(dst_ext, 0), set(imm, 1), uses=arch/x86/mov/ri, set(dst_lo, 6), set(dst_ext, 0), set(imm, $buffer), uses=arch/x86/mov/ri, set(dst_lo, 2), set(dst_ext, 0), set(imm, $length), uses=arch/x86/mov/ri, uses=arch/x86/syscall

  # syscall_exit: exit(code)
  # mov rax, 60; mov rdi, code; syscall
  syscall_exit -> set(dst_lo, 0), set(dst_ext, 0), set(imm, 60), uses=arch/x86/mov/ri, set(dst_lo, 7), set(dst_ext, 0), set(imm, $exit_code), uses=arch/x86/mov/ri, uses=arch/x86/syscall

  # syscall_read: read(fd, buffer, count)
  # mov rax, 0; mov rdi, $fd; mov rsi, $buffer; mov rdx, $count; syscall
  syscall_read -> set(dst_lo, 0), set(dst_ext, 0), set(imm, 0), uses=arch/x86/mov/ri, set(dst_lo, 7), set(dst_ext, 0), set(imm, $fd), uses=arch/x86/mov/ri, set(dst_lo, 6), set(dst_ext, 0), set(imm, $buffer), uses=arch/x86/mov/ri, set(dst_lo, 2), set(dst_ext, 0), set(imm, $count), uses=arch/x86/mov/ri, uses=arch/x86/syscall

  # syscall_open: open(path, flags, mode)
  # mov rax, 2; mov rdi, $path; mov rsi, $flags; mov rdx, $mode; syscall
  syscall_open -> set(dst_lo, 0), set(dst_ext, 0), set(imm, 2), uses=arch/x86/mov/ri, set(dst_lo, 7), set(dst_ext, 0), set(imm, $path), uses=arch/x86/mov/ri, set(dst_lo, 6), set(dst_ext, 0), set(imm, $flags), uses=arch/x86/mov/ri, set(dst_lo, 2), set(dst_ext, 0), set(imm, $mode), uses=arch/x86/mov/ri, uses=arch/x86/syscall

  # read_argc: mov rax, [rsp]
  read_argc -> uses=os/linux/argv/argc

  # read_argv: mov rax, [rsp + 8 + index*8]
  read_argv -> uses=os/linux/argv/argv

  # strcmp: compare strings at rsi and rdi, result in rax
  strcmp -> uses=os/linux/strings/strcmp

  # jmp_if_eq: jump if rax == 0
  jmp_if_eq -> uses=arch/x86/jumps/jmp_if_eq

  # jmp_if_ne: jump if rax != 0
  jmp_if_ne -> set(src_lo, 0), set(src_ext, 0), set(dst_lo, 0), set(dst_ext, 0), uses=arch/x86/arithmetic/test, set(target, $target), uses=arch/x86/jumps/jne

# =============================================================================
# LINKS - Lowering pipeline
# =============================================================================

L lower_all: operations -> instructions (deps=1)

L lower_one: operation -> instruction_seq (deps=0)

returns: instructions
