# X86

**Cost**: B + D×L = 140 + 1×0.288 = 140.288

---

## Structure

```
structure X86

B instruction: mov_rr | mov_rm | mov_mr | mov_ri | mov_rm_disp | mov_mr_disp | mov_rm_sib | mov_mr_sib | mov_rip | lea | lea_sib | lea_rip | push | pop | add_rr | add_ri | sub_rr | sub_ri | and_rr | and_ri | or_rr | or_ri | xor_rr | xor_ri | cmp_rr | cmp_ri | test_rr | test_ri | imul_rr | imul_ri | idiv | mul | div | shl_ri | shr_ri | sar_ri | shl_cl | shr_cl | sar_cl | rol_ri | ror_ri | rol_cl | ror_cl | inc | dec | neg | not | cqo | cdq | movsx | movzx | xchg | bswap | bsf | bsr | lzcnt | tzcnt | cmove | cmovne | cmovl | cmovge | cmovle | cmovg | cmova | cmovae | cmovb | cmovbe | cmovs | cmovns | sete | setne | setl | setge | setle | setg | seta | setae | setb | setbe | sets | setns | call | ret | leave | jmp | jmp_rel8 | je | jne | jl | jge | jle | jg | ja | jae | jb | jbe | js | jns | je_rel8 | jne_rel8 | jl_rel8 | jge_rel8 | jle_rel8 | jg_rel8 | ja_rel8 | jae_rel8 | jb_rel8 | jbe_rel8 | js_rel8 | jns_rel8 | rep_movsb | rep_movsq | rep_stosb | rep_stosq | lock_cmpxchg | lock_xadd | cmpxchg | xadd | int3 | ud2 | nop | syscall | prologue | epilogue
  mov_rr -> emit_byte(0x48), emit_byte(0x89), modrm(3, $src, $dst)
  mov_rm -> emit_byte(0x48), emit_byte(0x8B), modrm(0, $dst, $src)
  mov_mr -> emit_byte(0x48), emit_byte(0x89), modrm(0, $src, $dst)
  mov_ri -> rex(1, 0, 0, $dst_ext), emit_byte(0xB8 + $dst_lo), emit_u64($imm)
  mov_rm_disp -> emit_byte(0x48), emit_byte(0x8B), modrm(2, $dst, $src), emit_u32($disp)
  mov_mr_disp -> emit_byte(0x48), emit_byte(0x89), modrm(2, $src, $dst), emit_u32($disp)
  mov_rm_sib -> emit_byte(0x48), emit_byte(0x8B), modrm(2, $dst, 4), sib($scale, $index, $base), emit_u32($disp)
  mov_mr_sib -> emit_byte(0x48), emit_byte(0x89), modrm(2, $src, 4), sib($scale, $index, $base), emit_u32($disp)
  mov_rip -> emit_byte(0x48), emit_byte(0x8B), modrm(0, $dst, 5), emit_u32($disp)
  lea -> emit_byte(0x48), emit_byte(0x8D), modrm(2, $dst, $src), emit_u32($disp)
  lea_sib -> emit_byte(0x48), emit_byte(0x8D), modrm(2, $dst, 4), sib($scale, $index, $base), emit_u32($disp)
  lea_rip -> emit_byte(0x48), emit_byte(0x8D), modrm(0, $dst, 5), emit_u32($disp)
  push -> rex(0, 0, 0, $reg_ext), emit_byte(0x50 + $reg_lo)
  pop -> rex(0, 0, 0, $reg_ext), emit_byte(0x58 + $reg_lo)
  add_rr -> emit_byte(0x48), emit_byte(0x01), modrm(3, $src, $dst)
  add_ri -> emit_byte(0x48), emit_byte(0x81), modrm(3, 0, $dst), emit_u32($imm)
  sub_rr -> emit_byte(0x48), emit_byte(0x29), modrm(3, $src, $dst)
  sub_ri -> emit_byte(0x48), emit_byte(0x81), modrm(3, 5, $dst), emit_u32($imm)
  and_rr -> emit_byte(0x48), emit_byte(0x21), modrm(3, $src, $dst)
  and_ri -> emit_byte(0x48), emit_byte(0x81), modrm(3, 4, $dst), emit_u32($imm)
  or_rr -> emit_byte(0x48), emit_byte(0x09), modrm(3, $src, $dst)
  or_ri -> emit_byte(0x48), emit_byte(0x81), modrm(3, 1, $dst), emit_u32($imm)
  xor_rr -> emit_byte(0x48), emit_byte(0x31), modrm(3, $src, $dst)
  xor_ri -> emit_byte(0x48), emit_byte(0x81), modrm(3, 6, $dst), emit_u32($imm)
  cmp_rr -> emit_byte(0x48), emit_byte(0x39), modrm(3, $src, $dst)
  cmp_ri -> emit_byte(0x48), emit_byte(0x81), modrm(3, 7, $dst), emit_u32($imm)
  test_rr -> emit_byte(0x48), emit_byte(0x85), modrm(3, $src, $dst)
  test_ri -> emit_byte(0x48), emit_byte(0xF7), modrm(3, 0, $dst), emit_u32($imm)
  imul_rr -> emit_byte(0x48), emit_bytes(0x0F, 0xAF), modrm(3, $dst, $src)
  imul_ri -> emit_byte(0x48), emit_byte(0x69), modrm(3, $dst, $src), emit_u32($imm)
  idiv -> emit_byte(0x48), emit_byte(0xF7), modrm(3, 7, $src)
  mul -> emit_byte(0x48), emit_byte(0xF7), modrm(3, 4, $src)
  div -> emit_byte(0x48), emit_byte(0xF7), modrm(3, 6, $src)
  shl_ri -> emit_byte(0x48), emit_byte(0xC1), modrm(3, 4, $dst), emit_byte($imm)
  shr_ri -> emit_byte(0x48), emit_byte(0xC1), modrm(3, 5, $dst), emit_byte($imm)
  sar_ri -> emit_byte(0x48), emit_byte(0xC1), modrm(3, 7, $dst), emit_byte($imm)
  shl_cl -> emit_byte(0x48), emit_byte(0xD3), modrm(3, 4, $dst)
  shr_cl -> emit_byte(0x48), emit_byte(0xD3), modrm(3, 5, $dst)
  sar_cl -> emit_byte(0x48), emit_byte(0xD3), modrm(3, 7, $dst)
  rol_ri -> emit_byte(0x48), emit_byte(0xC1), modrm(3, 0, $dst), emit_byte($imm)
  ror_ri -> emit_byte(0x48), emit_byte(0xC1), modrm(3, 1, $dst), emit_byte($imm)
  rol_cl -> emit_byte(0x48), emit_byte(0xD3), modrm(3, 0, $dst)
  ror_cl -> emit_byte(0x48), emit_byte(0xD3), modrm(3, 1, $dst)
  inc -> emit_byte(0x48), emit_byte(0xFF), modrm(3, 0, $dst)
  dec -> emit_byte(0x48), emit_byte(0xFF), modrm(3, 1, $dst)
  neg -> emit_byte(0x48), emit_byte(0xF7), modrm(3, 3, $dst)
  not -> emit_byte(0x48), emit_byte(0xF7), modrm(3, 2, $dst)
  cqo -> emit_bytes(0x48, 0x99)
  cdq -> emit_byte(0x99)
  movsx -> emit_byte(0x48), emit_byte(0x63), modrm(3, $dst, $src)
  movzx -> emit_byte(0x48), emit_bytes(0x0F, 0xB6), modrm(3, $dst, $src)
  xchg -> emit_byte(0x48), emit_byte(0x87), modrm(3, $src, $dst)
  bswap -> emit_byte(0x48), emit_bytes(0x0F, 0xC8 + $dst_lo)
  bsf -> emit_byte(0x48), emit_bytes(0x0F, 0xBC), modrm(3, $dst, $src)
  bsr -> emit_byte(0x48), emit_bytes(0x0F, 0xBD), modrm(3, $dst, $src)
  lzcnt -> emit_byte(0xF3), emit_byte(0x48), emit_bytes(0x0F, 0xBD), modrm(3, $dst, $src)
  tzcnt -> emit_byte(0xF3), emit_byte(0x48), emit_bytes(0x0F, 0xBC), modrm(3, $dst, $src)
  cmove -> emit_byte(0x48), emit_bytes(0x0F, 0x44), modrm(3, $dst, $src)
  cmovne -> emit_byte(0x48), emit_bytes(0x0F, 0x45), modrm(3, $dst, $src)
  cmovl -> emit_byte(0x48), emit_bytes(0x0F, 0x4C), modrm(3, $dst, $src)
  cmovge -> emit_byte(0x48), emit_bytes(0x0F, 0x4D), modrm(3, $dst, $src)
  cmovle -> emit_byte(0x48), emit_bytes(0x0F, 0x4E), modrm(3, $dst, $src)
  cmovg -> emit_byte(0x48), emit_bytes(0x0F, 0x4F), modrm(3, $dst, $src)
  cmova -> emit_byte(0x48), emit_bytes(0x0F, 0x47), modrm(3, $dst, $src)
  cmovae -> emit_byte(0x48), emit_bytes(0x0F, 0x43), modrm(3, $dst, $src)
  cmovb -> emit_byte(0x48), emit_bytes(0x0F, 0x42), modrm(3, $dst, $src)
  cmovbe -> emit_byte(0x48), emit_bytes(0x0F, 0x46), modrm(3, $dst, $src)
  cmovs -> emit_byte(0x48), emit_bytes(0x0F, 0x48), modrm(3, $dst, $src)
  cmovns -> emit_byte(0x48), emit_bytes(0x0F, 0x49), modrm(3, $dst, $src)
  sete -> emit_bytes(0x0F, 0x94), modrm(3, 0, $dst)
  setne -> emit_bytes(0x0F, 0x95), modrm(3, 0, $dst)
  setl -> emit_bytes(0x0F, 0x9C), modrm(3, 0, $dst)
  setge -> emit_bytes(0x0F, 0x9D), modrm(3, 0, $dst)
  setle -> emit_bytes(0x0F, 0x9E), modrm(3, 0, $dst)
  setg -> emit_bytes(0x0F, 0x9F), modrm(3, 0, $dst)
  seta -> emit_bytes(0x0F, 0x97), modrm(3, 0, $dst)
  setae -> emit_bytes(0x0F, 0x93), modrm(3, 0, $dst)
  setb -> emit_bytes(0x0F, 0x92), modrm(3, 0, $dst)
  setbe -> emit_bytes(0x0F, 0x96), modrm(3, 0, $dst)
  sets -> emit_bytes(0x0F, 0x98), modrm(3, 0, $dst)
  setns -> emit_bytes(0x0F, 0x99), modrm(3, 0, $dst)
  call -> emit_byte(0xE8), reloc($target)
  ret -> emit_byte(0xC3)
  leave -> emit_byte(0xC9)
  jmp -> emit_byte(0xE9), reloc($target)
  jmp_rel8 -> emit_byte(0xEB), emit_byte($offset)
  je -> emit_bytes(0x0F, 0x84), reloc($target)
  jne -> emit_bytes(0x0F, 0x85), reloc($target)
  jl -> emit_bytes(0x0F, 0x8C), reloc($target)
  jge -> emit_bytes(0x0F, 0x8D), reloc($target)
  jle -> emit_bytes(0x0F, 0x8E), reloc($target)
  jg -> emit_bytes(0x0F, 0x8F), reloc($target)
  ja -> emit_bytes(0x0F, 0x87), reloc($target)
  jae -> emit_bytes(0x0F, 0x83), reloc($target)
  jb -> emit_bytes(0x0F, 0x82), reloc($target)
  jbe -> emit_bytes(0x0F, 0x86), reloc($target)
  js -> emit_bytes(0x0F, 0x88), reloc($target)
  jns -> emit_bytes(0x0F, 0x89), reloc($target)
  je_rel8 -> emit_byte(0x74), emit_byte($offset)
  jne_rel8 -> emit_byte(0x75), emit_byte($offset)
  jl_rel8 -> emit_byte(0x7C), emit_byte($offset)
  jge_rel8 -> emit_byte(0x7D), emit_byte($offset)
  jle_rel8 -> emit_byte(0x7E), emit_byte($offset)
  jg_rel8 -> emit_byte(0x7F), emit_byte($offset)
  ja_rel8 -> emit_byte(0x77), emit_byte($offset)
  jae_rel8 -> emit_byte(0x73), emit_byte($offset)
  jb_rel8 -> emit_byte(0x72), emit_byte($offset)
  jbe_rel8 -> emit_byte(0x76), emit_byte($offset)
  js_rel8 -> emit_byte(0x78), emit_byte($offset)
  jns_rel8 -> emit_byte(0x79), emit_byte($offset)
  rep_movsb -> emit_bytes(0xF3, 0xA4)
  rep_movsq -> emit_bytes(0xF3, 0x48, 0xA5)
  rep_stosb -> emit_bytes(0xF3, 0xAA)
  rep_stosq -> emit_bytes(0xF3, 0x48, 0xAB)
  lock_cmpxchg -> emit_byte(0xF0), emit_byte(0x48), emit_bytes(0x0F, 0xB1), modrm(0, $src, $dst)
  lock_xadd -> emit_byte(0xF0), emit_byte(0x48), emit_bytes(0x0F, 0xC1), modrm(0, $src, $dst)
  cmpxchg -> emit_byte(0x48), emit_bytes(0x0F, 0xB1), modrm(3, $src, $dst)
  xadd -> emit_byte(0x48), emit_bytes(0x0F, 0xC1), modrm(3, $src, $dst)
  int3 -> emit_byte(0xCC)
  ud2 -> emit_bytes(0x0F, 0x0B)
  nop -> emit_byte(0x90)
  syscall -> emit_bytes(0x0F, 0x05)
  prologue -> emit_byte(0x55), emit_bytes(0x48, 0x89, 0xE5)
  epilogue -> emit_byte(0x5D), emit_byte(0xC3)
B reg_encode: rax | rcx | rdx | rbx | rsp | rbp | rsi | rdi | r8 | r9 | r10 | r11 | r12 | r13 | r14 | r15
  rax -> set(reg_lo, 0), set(reg_ext, 0)
  rcx -> set(reg_lo, 1), set(reg_ext, 0)
  rdx -> set(reg_lo, 2), set(reg_ext, 0)
  rbx -> set(reg_lo, 3), set(reg_ext, 0)
  rsp -> set(reg_lo, 4), set(reg_ext, 0)
  rbp -> set(reg_lo, 5), set(reg_ext, 0)
  rsi -> set(reg_lo, 6), set(reg_ext, 0)
  rdi -> set(reg_lo, 7), set(reg_ext, 0)
  r8 -> set(reg_lo, 0), set(reg_ext, 1)
  r9 -> set(reg_lo, 1), set(reg_ext, 1)
  r10 -> set(reg_lo, 2), set(reg_ext, 1)
  r11 -> set(reg_lo, 3), set(reg_ext, 1)
  r12 -> set(reg_lo, 4), set(reg_ext, 1)
  r13 -> set(reg_lo, 5), set(reg_ext, 1)
  r14 -> set(reg_lo, 6), set(reg_ext, 1)
  r15 -> set(reg_lo, 7), set(reg_ext, 1)

L encode_all: instructions -> output (deps=1)
L encode_one: instruction -> output (deps=1)

D instructions: N [input, sequential]
D output: M [output, sequential]

returns: output
```

## Boundaries (B)

| Boundary | Partitions | Properties |
|----------|------------|------------|
| instruction | mov_rr \| mov_rm \| mov_mr \| mov_ri \| mov_rm_disp \| mov_mr_disp \| mov_rm_sib \| mov_mr_sib \| mov_rip \| lea \| lea_sib \| lea_rip \| push \| pop \| add_rr \| add_ri \| sub_rr \| sub_ri \| and_rr \| and_ri \| or_rr \| or_ri \| xor_rr \| xor_ri \| cmp_rr \| cmp_ri \| test_rr \| test_ri \| imul_rr \| imul_ri \| idiv \| mul \| div \| shl_ri \| shr_ri \| sar_ri \| shl_cl \| shr_cl \| sar_cl \| rol_ri \| ror_ri \| rol_cl \| ror_cl \| inc \| dec \| neg \| not \| cqo \| cdq \| movsx \| movzx \| xchg \| bswap \| bsf \| bsr \| lzcnt \| tzcnt \| cmove \| cmovne \| cmovl \| cmovge \| cmovle \| cmovg \| cmova \| cmovae \| cmovb \| cmovbe \| cmovs \| cmovns \| sete \| setne \| setl \| setge \| setle \| setg \| seta \| setae \| setb \| setbe \| sets \| setns \| call \| ret \| leave \| jmp \| jmp_rel8 \| je \| jne \| jl \| jge \| jle \| jg \| ja \| jae \| jb \| jbe \| js \| jns \| je_rel8 \| jne_rel8 \| jl_rel8 \| jge_rel8 \| jle_rel8 \| jg_rel8 \| ja_rel8 \| jae_rel8 \| jb_rel8 \| jbe_rel8 \| js_rel8 \| jns_rel8 \| rep_movsb \| rep_movsq \| rep_stosb \| rep_stosq \| lock_cmpxchg \| lock_xadd \| cmpxchg \| xadd \| int3 \| ud2 \| nop \| syscall \| prologue \| epilogue | topological |
| reg_encode | rax \| rcx \| rdx \| rbx \| rsp \| rbp \| rsi \| rdi \| r8 \| r9 \| r10 \| r11 \| r12 \| r13 \| r14 \| r15 | topological |

## Links (L)

| Link | Source | Target | deps | Attributes |
|------|--------|--------|------|------------|
| encode_all | instructions | output | 1 |  |
| encode_one | instruction | output | 1 |  |

## Dimensions (D)

| Dimension | Extent | Properties |
|-----------|--------|------------|
| instructions | N | input, sequential |
| output | M | output, sequential |

## Returns

`output`
