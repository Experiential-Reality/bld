# elf.bld - ELF64 executable format as BLD
#
# Structure IS Computation: traversing emits a complete ELF executable.
#
# ELF64 layout:
#   - ELF header: 64 bytes
#   - Program header: 56 bytes
#   - Code: N bytes (at offset 0x78 = 120)
#
# Constants:
#   base_addr = 0x400000
#   code_offset = 0x78 (120)
#   entry = base_addr + code_offset = 0x400078

structure ELF64

D bytes: 120 + N [composed]

# =============================================================================
# ELF HEADER (64 bytes)
# =============================================================================

B elf_header: magic | class | data | version | osabi | pad | e_type | e_machine | e_version | e_entry | e_phoff | e_shoff | e_flags | e_ehsize | e_phentsize | e_phnum | e_shentsize | e_shnum | e_shstrndx

  # Magic: 0x7f 'E' 'L' 'F'
  magic -> set(value, 0x7f), uses=emit/byte, set(value, 0x45), uses=emit/byte, set(value, 0x4c), uses=emit/byte, set(value, 0x46), uses=emit/byte

  # EI_CLASS: 2 = 64-bit
  class -> set(value, 0x02), uses=emit/byte

  # EI_DATA: 1 = little-endian
  data -> set(value, 0x01), uses=emit/byte

  # EI_VERSION: 1
  version -> set(value, 0x01), uses=emit/byte

  # EI_OSABI: 0 = SYSV
  osabi -> set(value, 0x00), uses=emit/byte

  # Padding: 8 bytes
  pad -> set(value, 0), uses=emit/byte, set(value, 0), uses=emit/byte, set(value, 0), uses=emit/byte, set(value, 0), uses=emit/byte, set(value, 0), uses=emit/byte, set(value, 0), uses=emit/byte, set(value, 0), uses=emit/byte, set(value, 0), uses=emit/byte

  # e_type: 2 = ET_EXEC
  e_type -> set(value, 0x0002), uses=emit/u16

  # e_machine: 0x3e = x86-64
  e_machine -> set(value, 0x003e), uses=emit/u16

  # e_version: 1
  e_version -> set(value, 0x00000001), uses=emit/u32

  # e_entry: entry point (base + code_offset)
  e_entry -> set(value, $entry), uses=emit/u64

  # e_phoff: program header offset = 64 (0x40)
  e_phoff -> set(value, 0x40), uses=emit/u64

  # e_shoff: section header offset = 0 (none)
  e_shoff -> set(value, 0), uses=emit/u64

  # e_flags: 0
  e_flags -> set(value, 0), uses=emit/u32

  # e_ehsize: ELF header size = 64 (0x40)
  e_ehsize -> set(value, 0x40), uses=emit/u16

  # e_phentsize: program header entry size = 56 (0x38)
  e_phentsize -> set(value, 0x38), uses=emit/u16

  # e_phnum: number of program headers = 1
  e_phnum -> set(value, 1), uses=emit/u16

  # e_shentsize: section header entry size = 64 (0x40)
  e_shentsize -> set(value, 0x40), uses=emit/u16

  # e_shnum: number of section headers = 0
  e_shnum -> set(value, 0), uses=emit/u16

  # e_shstrndx: section name string table index = 0
  e_shstrndx -> set(value, 0), uses=emit/u16

# =============================================================================
# PROGRAM HEADER (56 bytes)
# =============================================================================

B phdr: p_type | p_flags | p_offset | p_vaddr | p_paddr | p_filesz | p_memsz | p_align

  # p_type: 1 = PT_LOAD
  p_type -> set(value, 1), uses=emit/u32

  # p_flags: 5 = PF_R | PF_X (readable + executable)
  p_flags -> set(value, 5), uses=emit/u32

  # p_offset: file offset = 0 (load from beginning)
  p_offset -> set(value, 0), uses=emit/u64

  # p_vaddr: virtual address = base_addr (0x400000)
  p_vaddr -> set(value, $base_addr), uses=emit/u64

  # p_paddr: physical address = base_addr
  p_paddr -> set(value, $base_addr), uses=emit/u64

  # p_filesz: file size (total = header + code)
  p_filesz -> set(value, $filesz), uses=emit/u64

  # p_memsz: memory size (same as file size for simple executable)
  p_memsz -> set(value, $memsz), uses=emit/u64

  # p_align: alignment = 0x1000 (page)
  p_align -> set(value, 0x1000), uses=emit/u64

# =============================================================================
# CODE SECTION
# =============================================================================

B code: replay_code
  replay_code -> replay($code)

returns: output
