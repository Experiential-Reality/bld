# aarch64.bld - AArch64 (ARM 64-bit) instruction encoding as executable BLD
#
# When traversed, this structure emits AArch64 machine code.
# All instructions are 32-bit, little-endian.
#
# Usage: traverse(AArch64, instructions=[...]) -> bytes
#
# AArch64 instruction formats (all 32-bit):
#   Data Processing (Register): sf opc S Rm ... Rn Rd
#   Data Processing (Immediate): sf opc S ... imm12 Rn Rd
#   Load/Store: size V opc ... imm Rn Rt
#   Branch: op ... imm26/imm19
#   System: ... op0 op1 CRn CRm op2 Rt
#
# Linux syscalls: x8=syscall#, x0-x5=args, svc #0
#   write: x8=64, x0=fd, x1=buf, x2=len
#   exit:  x8=93, x0=code

structure AArch64

# =============================================================================
# DIMENSIONS
# =============================================================================

D instructions: N [input, sequential]
D output: M [output, sequential]

# =============================================================================
# BOUNDARIES - Instruction dispatch
# =============================================================================

B instruction: add_rr | add_ri | sub_rr | sub_ri | adds_rr | subs_rr | and_rr | and_ri | orr_rr | orr_ri | eor_rr | eor_ri | mov_rr | mov_ri | movz | movk | movn | ldr | ldrb | ldrh | ldrsw | ldrsb | ldrsh | str | strb | strh | ldp | stp | b | bl | br | blr | ret | cbz | cbnz | tbz | tbnz | cmp_rr | cmp_ri | tst_rr | beq | bne | blt | bgt | ble | bge | blo | bhi | bls | bhs | svc | nop | prologue | epilogue

  # ===========================================================================
  # Data Processing - Register (64-bit)
  # ===========================================================================

  # ADD Xd, Xn, Xm: sf=1 opc=00 S=0 ... 0x8B000000 | Rm<<16 | Rn<<5 | Rd
  add_rr -> emit_u32(0x8B000000 | ($rm << 16) | ($rn << 5) | $rd)

  # SUB Xd, Xn, Xm: sf=1 opc=10 S=0 ... 0xCB000000 | Rm<<16 | Rn<<5 | Rd
  sub_rr -> emit_u32(0xCB000000 | ($rm << 16) | ($rn << 5) | $rd)

  # ADDS Xd, Xn, Xm (sets flags): 0xAB000000 | Rm<<16 | Rn<<5 | Rd
  adds_rr -> emit_u32(0xAB000000 | ($rm << 16) | ($rn << 5) | $rd)

  # SUBS Xd, Xn, Xm (sets flags): 0xEB000000 | Rm<<16 | Rn<<5 | Rd
  subs_rr -> emit_u32(0xEB000000 | ($rm << 16) | ($rn << 5) | $rd)

  # AND Xd, Xn, Xm: 0x8A000000 | Rm<<16 | Rn<<5 | Rd
  and_rr -> emit_u32(0x8A000000 | ($rm << 16) | ($rn << 5) | $rd)

  # ORR Xd, Xn, Xm: 0xAA000000 | Rm<<16 | Rn<<5 | Rd
  orr_rr -> emit_u32(0xAA000000 | ($rm << 16) | ($rn << 5) | $rd)

  # EOR Xd, Xn, Xm: 0xCA000000 | Rm<<16 | Rn<<5 | Rd
  eor_rr -> emit_u32(0xCA000000 | ($rm << 16) | ($rn << 5) | $rd)

  # ===========================================================================
  # Data Processing - Immediate
  # ===========================================================================

  # ADD Xd, Xn, #imm: 0x91000000 | imm12<<10 | Rn<<5 | Rd
  add_ri -> emit_u32(0x91000000 | (($imm & 0xFFF) << 10) | ($rn << 5) | $rd)

  # SUB Xd, Xn, #imm: 0xD1000000 | imm12<<10 | Rn<<5 | Rd
  sub_ri -> emit_u32(0xD1000000 | (($imm & 0xFFF) << 10) | ($rn << 5) | $rd)

  # AND Xd, Xn, #imm (bitmask immediate - simplified): 0x92000000 | ...
  and_ri -> emit_u32(0x92400000 | ($rn << 5) | $rd | (($imm & 0x3F) << 10))

  # ORR Xd, Xn, #imm (bitmask immediate - simplified): 0xB2000000 | ...
  orr_ri -> emit_u32(0xB2400000 | ($rn << 5) | $rd | (($imm & 0x3F) << 10))

  # EOR Xd, Xn, #imm (bitmask immediate - simplified): 0xD2000000 | ...
  eor_ri -> emit_u32(0xD2400000 | ($rn << 5) | $rd | (($imm & 0x3F) << 10))

  # ===========================================================================
  # Move instructions
  # ===========================================================================

  # MOV Xd, Xn (alias for ORR Xd, XZR, Xn): 0xAA0003E0 | Rm<<16 | Rd
  mov_rr -> emit_u32(0xAA0003E0 | ($rm << 16) | $rd)

  # MOV Xd, #imm (alias for MOVZ/MOVN depending on value): 0xD2800000 | imm16<<5 | Rd
  mov_ri -> emit_u32(0xD2800000 | (($imm & 0xFFFF) << 5) | $rd)

  # MOVZ Xd, #imm{, LSL #shift}: 0xD2800000 | hw<<21 | imm16<<5 | Rd
  movz -> emit_u32(0xD2800000 | (($shift & 0x30) << 17) | (($imm & 0xFFFF) << 5) | $rd)

  # MOVK Xd, #imm{, LSL #shift}: 0xF2800000 | hw<<21 | imm16<<5 | Rd
  movk -> emit_u32(0xF2800000 | (($shift & 0x30) << 17) | (($imm & 0xFFFF) << 5) | $rd)

  # MOVN Xd, #imm{, LSL #shift}: 0x92800000 | hw<<21 | imm16<<5 | Rd
  movn -> emit_u32(0x92800000 | (($shift & 0x30) << 17) | (($imm & 0xFFFF) << 5) | $rd)

  # ===========================================================================
  # Load/Store - Unsigned offset
  # ===========================================================================

  # LDR Xt, [Xn, #offset]: 0xF9400000 | (offset/8)<<10 | Rn<<5 | Rt
  ldr -> emit_u32(0xF9400000 | ((($offset >> 3) & 0xFFF) << 10) | ($rn << 5) | $rt)

  # LDRB Wt, [Xn, #offset]: 0x39400000 | offset<<10 | Rn<<5 | Rt
  ldrb -> emit_u32(0x39400000 | (($offset & 0xFFF) << 10) | ($rn << 5) | $rt)

  # LDRH Wt, [Xn, #offset]: 0x79400000 | (offset/2)<<10 | Rn<<5 | Rt
  ldrh -> emit_u32(0x79400000 | ((($offset >> 1) & 0xFFF) << 10) | ($rn << 5) | $rt)

  # LDRSW Xt, [Xn, #offset]: 0xB9800000 | (offset/4)<<10 | Rn<<5 | Rt
  ldrsw -> emit_u32(0xB9800000 | ((($offset >> 2) & 0xFFF) << 10) | ($rn << 5) | $rt)

  # LDRSB Xt, [Xn, #offset]: 0x39800000 | offset<<10 | Rn<<5 | Rt
  ldrsb -> emit_u32(0x39800000 | (($offset & 0xFFF) << 10) | ($rn << 5) | $rt)

  # LDRSH Xt, [Xn, #offset]: 0x79800000 | (offset/2)<<10 | Rn<<5 | Rt
  ldrsh -> emit_u32(0x79800000 | ((($offset >> 1) & 0xFFF) << 10) | ($rn << 5) | $rt)

  # STR Xt, [Xn, #offset]: 0xF9000000 | (offset/8)<<10 | Rn<<5 | Rt
  str -> emit_u32(0xF9000000 | ((($offset >> 3) & 0xFFF) << 10) | ($rn << 5) | $rt)

  # STRB Wt, [Xn, #offset]: 0x39000000 | offset<<10 | Rn<<5 | Rt
  strb -> emit_u32(0x39000000 | (($offset & 0xFFF) << 10) | ($rn << 5) | $rt)

  # STRH Wt, [Xn, #offset]: 0x79000000 | (offset/2)<<10 | Rn<<5 | Rt
  strh -> emit_u32(0x79000000 | ((($offset >> 1) & 0xFFF) << 10) | ($rn << 5) | $rt)

  # ===========================================================================
  # Load/Store Pair
  # ===========================================================================

  # LDP Xt1, Xt2, [Xn, #offset]: 0xA9400000 | (offset/8)<<15 | Rt2<<10 | Rn<<5 | Rt1
  ldp -> emit_u32(0xA9400000 | (((($offset >> 3) & 0x7F) << 15)) | ($rt2 << 10) | ($rn << 5) | $rt)

  # STP Xt1, Xt2, [Xn, #offset]: 0xA9000000 | (offset/8)<<15 | Rt2<<10 | Rn<<5 | Rt1
  stp -> emit_u32(0xA9000000 | (((($offset >> 3) & 0x7F) << 15)) | ($rt2 << 10) | ($rn << 5) | $rt)

  # ===========================================================================
  # Branch instructions
  # ===========================================================================

  # B label: 0x14000000 | (offset/4 & 0x3FFFFFF)
  b -> emit_u32(0x14000000 | ((($offset >> 2) & 0x3FFFFFF)))

  # BL label: 0x94000000 | (offset/4 & 0x3FFFFFF)
  bl -> emit_u32(0x94000000 | ((($offset >> 2) & 0x3FFFFFF)))

  # BR Xn: 0xD61F0000 | Rn<<5
  br -> emit_u32(0xD61F0000 | ($rn << 5))

  # BLR Xn: 0xD63F0000 | Rn<<5
  blr -> emit_u32(0xD63F0000 | ($rn << 5))

  # RET {Xn}: 0xD65F0000 | Rn<<5 (default Rn=30/x30/lr)
  ret -> emit_u32(0xD65F03C0)

  # ===========================================================================
  # Compare and Branch
  # ===========================================================================

  # CBZ Xt, label: 0xB4000000 | (offset/4)<<5 | Rt
  cbz -> emit_u32(0xB4000000 | (((($offset >> 2) & 0x7FFFF) << 5)) | $rt)

  # CBNZ Xt, label: 0xB5000000 | (offset/4)<<5 | Rt
  cbnz -> emit_u32(0xB5000000 | (((($offset >> 2) & 0x7FFFF) << 5)) | $rt)

  # TBZ Xt, #bit, label: 0x36000000 | b5<<31 | b40<<19 | (offset/4)<<5 | Rt
  tbz -> emit_u32(0x36000000 | ((($bit >> 5) & 0x1) << 31) | (($bit & 0x1F) << 19) | (((($offset >> 2) & 0x3FFF) << 5)) | $rt)

  # TBNZ Xt, #bit, label: 0x37000000 | b5<<31 | b40<<19 | (offset/4)<<5 | Rt
  tbnz -> emit_u32(0x37000000 | ((($bit >> 5) & 0x1) << 31) | (($bit & 0x1F) << 19) | (((($offset >> 2) & 0x3FFF) << 5)) | $rt)

  # ===========================================================================
  # Compare instructions
  # ===========================================================================

  # CMP Xn, Xm (alias for SUBS XZR, Xn, Xm): 0xEB00001F | Rm<<16 | Rn<<5
  cmp_rr -> emit_u32(0xEB00001F | ($rm << 16) | ($rn << 5))

  # CMP Xn, #imm (alias for SUBS XZR, Xn, #imm): 0xF100001F | imm12<<10 | Rn<<5
  cmp_ri -> emit_u32(0xF100001F | (($imm & 0xFFF) << 10) | ($rn << 5))

  # TST Xn, Xm (alias for ANDS XZR, Xn, Xm): 0xEA00001F | Rm<<16 | Rn<<5
  tst_rr -> emit_u32(0xEA00001F | ($rm << 16) | ($rn << 5))

  # ===========================================================================
  # Conditional Branch
  # ===========================================================================

  # B.cond label: 0x54000000 | (offset/4)<<5 | cond
  # EQ=0, NE=1, CS/HS=2, CC/LO=3, MI=4, PL=5, VS=6, VC=7
  # HI=8, LS=9, GE=10, LT=11, GT=12, LE=13, AL=14

  # B.EQ label: 0x54000000 | (offset/4)<<5 | 0
  beq -> emit_u32(0x54000000 | (((($offset >> 2) & 0x7FFFF) << 5)) | 0x0)

  # B.NE label: 0x54000001
  bne -> emit_u32(0x54000000 | (((($offset >> 2) & 0x7FFFF) << 5)) | 0x1)

  # B.LT label: 0x5400000B
  blt -> emit_u32(0x54000000 | (((($offset >> 2) & 0x7FFFF) << 5)) | 0xB)

  # B.GT label: 0x5400000C
  bgt -> emit_u32(0x54000000 | (((($offset >> 2) & 0x7FFFF) << 5)) | 0xC)

  # B.LE label: 0x5400000D
  ble -> emit_u32(0x54000000 | (((($offset >> 2) & 0x7FFFF) << 5)) | 0xD)

  # B.GE label: 0x5400000A
  bge -> emit_u32(0x54000000 | (((($offset >> 2) & 0x7FFFF) << 5)) | 0xA)

  # B.LO/B.CC label: 0x54000003
  blo -> emit_u32(0x54000000 | (((($offset >> 2) & 0x7FFFF) << 5)) | 0x3)

  # B.HI label: 0x54000008
  bhi -> emit_u32(0x54000000 | (((($offset >> 2) & 0x7FFFF) << 5)) | 0x8)

  # B.LS label: 0x54000009
  bls -> emit_u32(0x54000000 | (((($offset >> 2) & 0x7FFFF) << 5)) | 0x9)

  # B.HS/B.CS label: 0x54000002
  bhs -> emit_u32(0x54000000 | (((($offset >> 2) & 0x7FFFF) << 5)) | 0x2)

  # ===========================================================================
  # System instructions
  # ===========================================================================

  # SVC #imm: 0xD4000001 | imm16<<5
  svc -> emit_u32(0xD4000001 | (($imm & 0xFFFF) << 5))

  # NOP: 0xD503201F
  nop -> emit_u32(0xD503201F)

  # ===========================================================================
  # Function prologue/epilogue
  # ===========================================================================

  # Prologue: stp x29, x30, [sp, #-16]!; mov x29, sp
  prologue -> emit_u32(0xA9BF7BFD), emit_u32(0x910003FD)

  # Epilogue: ldp x29, x30, [sp], #16; ret
  epilogue -> emit_u32(0xA8C17BFD), emit_u32(0xD65F03C0)

# =============================================================================
# BOUNDARIES - Register encoding (x0-x30, sp, xzr)
# =============================================================================

B reg_encode: x0 | x1 | x2 | x3 | x4 | x5 | x6 | x7 | x8 | x9 | x10 | x11 | x12 | x13 | x14 | x15 | x16 | x17 | x18 | x19 | x20 | x21 | x22 | x23 | x24 | x25 | x26 | x27 | x28 | x29 | x30 | sp | xzr | wzr
  x0 -> set(reg_num, 0)
  x1 -> set(reg_num, 1)
  x2 -> set(reg_num, 2)
  x3 -> set(reg_num, 3)
  x4 -> set(reg_num, 4)
  x5 -> set(reg_num, 5)
  x6 -> set(reg_num, 6)
  x7 -> set(reg_num, 7)
  x8 -> set(reg_num, 8)
  x9 -> set(reg_num, 9)
  x10 -> set(reg_num, 10)
  x11 -> set(reg_num, 11)
  x12 -> set(reg_num, 12)
  x13 -> set(reg_num, 13)
  x14 -> set(reg_num, 14)
  x15 -> set(reg_num, 15)
  x16 -> set(reg_num, 16)
  x17 -> set(reg_num, 17)
  x18 -> set(reg_num, 18)
  x19 -> set(reg_num, 19)
  x20 -> set(reg_num, 20)
  x21 -> set(reg_num, 21)
  x22 -> set(reg_num, 22)
  x23 -> set(reg_num, 23)
  x24 -> set(reg_num, 24)
  x25 -> set(reg_num, 25)
  x26 -> set(reg_num, 26)
  x27 -> set(reg_num, 27)
  x28 -> set(reg_num, 28)
  x29 -> set(reg_num, 29)
  x30 -> set(reg_num, 30)
  sp -> set(reg_num, 31)
  xzr -> set(reg_num, 31)
  wzr -> set(reg_num, 31)

# =============================================================================
# BOUNDARIES - ABI register aliases
# =============================================================================

B reg_alias: fp | lr | ip0 | ip1 | pr
  fp -> set(reg_num, 29)
  lr -> set(reg_num, 30)
  ip0 -> set(reg_num, 16)
  ip1 -> set(reg_num, 17)
  pr -> set(reg_num, 18)

# =============================================================================
# LINKS - Encoding pipeline
# =============================================================================

L encode_all: instructions -> output (deps=1)
L encode_one: instruction -> output (deps=1)

returns: output
