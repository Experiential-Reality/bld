# grammar.bld - BLD grammar as production rules
#
# Cost(grammar_matching) = B_rules + D_tokens × L_match
#   B_rules = |productions| = 18 links (invariant)
#   D_tokens = N (scales with input)
#   L_match = cost to check one production (geometric)
#
# This expresses the BLD grammar in a form closer to BNF/EBNF,
# using BLD's own primitives. Each Link is a production rule.
#
# Key insight: A grammar IS a structure.
#   - Nonterminals are nodes
#   - Productions are links from LHS to RHS
#   - Kleene star (*) is a dimension
#   - Alternation (|) is a boundary
#
# deps encodes evaluation order:
#   deps=0 → can evaluate in parallel (choice, optional)
#   deps=1 → must evaluate in sequence (concatenation)

structure BLDProductions

# =============================================================================
# DIMENSION: Repetition in grammar
# =============================================================================

D structures: N [parallel]      # file = structure*
D declarations: M [parallel]    # structure_body = declaration*
D partitions: K [parallel]      # partition_list = partition ("|" partition)*
D properties: P [parallel]      # prop_list = property ("," property)*
D attributes: A [parallel]      # attr_list = attr ("," attr)*
D semantics: S [parallel]       # semantic_block = semantic_line*

# =============================================================================
# BOUNDARY: Choice points in grammar
# =============================================================================

# What can appear at top level of file
B file_content: structure | comment | blank

# What can appear in a structure body
B declaration: B_decl | L_decl | D_decl | P_decl | returns_decl | semantic | comment

# What can follow a colon in extent position
B extent: number | identifier | expression

# What can appear in property brackets
B property: parallel | sequential | input | output | contiguous | scalar | type_spec | stride

# What can appear in link attributes
B attribute: deps_attr | pattern_attr | engine_attr | uses_attr | rho_attr | count_attr | ops_attr

# =============================================================================
# LINK: Production rules (grammar → concrete syntax)
# =============================================================================

# File level
L file: epsilon -> structures (deps=0)
L structure_prod: structure_kw -> body (deps=1)
L body: newline -> declarations (deps=1)

# Boundary declarations
L B_decl: B_kw -> partition_list (deps=1)
L partition_list: partition -> partitions (deps=0)
L partition: identifier -> name (deps=0)
L pipe_partition: pipe -> partition (deps=1)
L semantic_block: indent -> semantics (deps=1)
L semantic_line: identifier -> semantic_content (deps=1)

# Link declarations
L L_decl: L_kw -> flow (deps=1)
L attr_block: paren_open -> attributes (deps=1)
L attr_list: attr -> attributes (deps=0)
L attr: identifier -> value (deps=1)

# Dimension declarations
L D_decl: D_kw -> extent (deps=1)
L prop_block: bracket_open -> properties (deps=1)
L prop_list: property -> properties (deps=0)

# Parameter declarations (legacy)
L P_decl: P_kw -> type (deps=1)

# Returns declaration
L returns_decl: returns_kw -> type (deps=1)

# =============================================================================
# TERMINALS (Lexical rules - what the tokenizer produces)
# =============================================================================

# These would be in tokenizer.bld, referenced here for completeness
# L identifier: alpha alnum* -> token (deps=1)
# L number: digit+ -> token (deps=1)
# L string: '"' char* '"' -> token (deps=1)

# =============================================================================
# THE GRAMMAR IS A GRAPH
# =============================================================================

# Visualizing the productions as a graph:
#
#   file ──→ structure* ──→ body ──→ declaration*
#                │                        │
#                ├── B_decl ──→ partition_list ──→ semantic_block?
#                ├── L_decl ──→ flow ──→ attr_block?
#                ├── D_decl ──→ extent ──→ prop_block?
#                ├── P_decl ──→ type ──→ prop_block?
#                └── returns_decl ──→ type
#
# The parser traverses this graph, matching against the token stream.
# deps=1 links must be followed in order.
# deps=0 links can be matched in any order (choice points).

returns: Grammar
